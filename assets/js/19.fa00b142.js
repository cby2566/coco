(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{380:function(e,t,r){"use strict";r.r(t);var s=r(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"eventloop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[e._v("#")]),e._v(" EventLoop")]),e._v(" "),r("h2",{attrs:{id:"宏任务与微任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#宏任务与微任务"}},[e._v("#")]),e._v(" 宏任务与微任务")]),e._v(" "),r("p",[e._v("宏任务：setTimeout、setInterval、setImmediate、requestAnimationFrame、setImmediate(node)."),r("br"),e._v("\n微任务：Promise、try...catch...finally、process.nextTick(node)、MutationObserver.")]),e._v(" "),r("ul",[r("li",[e._v("async/await 本质上还是 Generator 函数的语法糖，而 function* 所返回的又是Promise对象。换句话说它本质上还是Promise的一些封装，而 Promise 是属于微任务的一种，所以它也算微任务。")]),e._v(" "),r("li",[e._v("都说 Promise 是微任务，但它应该拆开来看比较容易理解。首先 new Promise 实例的时候，其中形参所传入的匿名函数是"),r("strong",[e._v("同步执行")]),e._v("的(但这时 resolve 和 reject 被调用)，在那之后使用 then 方法时所传入的匿名函数才是"),r("strong",[e._v("微任务")]),e._v("。")]),e._v(" "),r("li",[e._v("主进程 -> 宏任务1 -> 微任务1~5 -> 宏任务2")])])])}),[],!1,null,null,null);t.default=n.exports}}]);